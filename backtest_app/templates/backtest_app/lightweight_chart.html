{% extends 'backtest_app/base.html' %}
{% load static %}
{% load humanize %}

{% block title %}{{ display_symbol }} Chart{% endblock %}

{% block extra_head %}
<script src="https://unpkg.com/lightweight-charts@5.0.9/dist/lightweight-charts.standalone.production.js"></script>
<style>
html, body { height:100%; margin:0; padding:0; overflow:hidden; }
.chart-fullscreen { width:100%; height:100vh; display:flex; flex-direction:column; padding:10px; box-sizing:border-box; }
.chart-page { display:flex; flex-direction:column; flex:1; min-height:0; height:100%; }
#chart-container { flex:1; position:relative; width:100%; min-height:400px; cursor:crosshair; }
.legend { position:absolute; top:10px; right:10px; background:rgba(255,255,255,0.8); padding:8px; border-radius:4px; font-size:12px; z-index:10; }
.info-overlay { position:absolute; top:0; right:0; background:rgba(255,255,255,0.85); padding:8px 15px; margin:10px; border-radius:5px; z-index:20; font-size:12px; box-shadow:0 2px 5px rgba(0,0,0,0.1); max-width:70%; }
.info-overlay p { margin:3px 0; display:inline-block; margin-right:15px; }
.timeframe-buttons { display:flex; gap:10px; margin-bottom:10px; }
.timeframe-btn { padding:8px 16px; background:#e0e0e0; border:none; border-radius:4px; cursor:pointer; font-weight:bold; }
.timeframe-btn.active { background:#007bff; color:white; }
.drawing-tools { display:flex; gap:10px; margin-bottom:10px; }
.drawing-btn { padding:8px 16px; background:#e0e0e0; border:none; border-radius:4px; cursor:pointer; }
.drawing-btn.active { background:#ff7043; color:white; }
</style>
{% endblock %}

{% block content %}
<div class="chart-fullscreen">
    <div id="info" class="info-overlay">
        <p><strong>Symbol:</strong> {{ display_symbol }}</p>
        <p><strong>Date Range:</strong> {{ start_date }} to {{ end_date }}</p>
    </div>
    {% if data_warning %}
    <div class="warning"><strong>Uwaga:</strong> {{ data_warning }}</div>
    {% endif %}
    <div class="timeframe-buttons">
        <button class="timeframe-btn" data-tf="1m">1m</button>
        <button class="timeframe-btn" data-tf="5m">5m</button>
        <button class="timeframe-btn" data-tf="15m">15m</button>
        <button class="timeframe-btn active" data-tf="1h">1h</button>
        <button class="timeframe-btn" data-tf="4h">4h</button>
        <button class="timeframe-btn" data-tf="1d">1d</button>
    </div>
    <div class="drawing-tools">
        <button id="line-tool" class="drawing-btn">Line Tool</button>
        <button id="fib-tool" class="drawing-btn">Fibbonaci</button>
        <button id="rect-tool" class="drawing-btn">Rectangle</button>
        <button id="clear-drawings" class="drawing-btn">Clear All</button>
    </div>
    <div class="chart-page">
        <div id="chart-container">
            <div id="legend" class="legend"></div>
        </div>
    </div>
    {% if debug %}
    <div style="margin-top:30px; padding:15px; background-color:#f5f5f5; border:1px solid #ddd;">
        <h3>Debug Info:</h3>
        <p>Display Symbol: {{ display_symbol }}</p>
        <p>Count: {{ count }}</p>
        <p>Chart Data Length (JSON): {{ chart_data|length }} bytes</p>
        <pre style="max-height:200px; overflow:auto; background:#eee; padding:10px;">{{ chart_data|slice:":500" }}...</pre>
    </div>
    {% endif %}
</div>
{% endblock %}

{% block scripts %}
<script>
console.log("Template loaded");

// Parse data from server
let chartData;
try {
    chartData = JSON.parse('{{ chart_data|escapejs }}');
    console.log("Chart data parsed:", Object.keys(chartData));
} catch(e) {
    console.error("JSON parse error:", e);
    chartData = {};
}

// DOM
const chartContainer = document.getElementById('chart-container');
const legendElement = document.getElementById('legend');
let currentTimeframe = '1h';

function prepareCandleData(data) {
    return data.map(d => ({
        time: Number(d.time),
        open: d.open,
        high: d.high,
        low: d.low,
        close: d.close
    }));
}

// Chart config
const chartOptions = {
    layout: { background:{color:'#fff'}, textColor:'#333' },
    grid: { vertLines:{color:'#f0f0f0'}, horzLines:{color:'#f0f0f0'} },
    crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
    rightPriceScale: { borderColor:'#d1d4dc' },
    timeScale: { borderColor:'#d1d4dc', timeVisible:true, secondsVisible:false },
    handleScroll: { vertTouchDrag:false },
};


const chart = LightweightCharts.createChart(chartContainer, chartOptions);

// Dodanie świec
const candleSeries = chart.addSeries(LightweightCharts.CandlestickSeries, {
    upColor: '#26a69a',
    downColor: '#ef5350',
    borderVisible: false,
    wickUpColor: '#26a69a',
    wickDownColor: '#ef5350'
});




function updateLegend(data) {
    if (!data) return;
    const dateStr = data.time ? new Date(data.time*1000).toLocaleString() : '';
    legendElement.innerHTML = `
        <div>O: <strong>${data.open.toFixed(2)}</strong></div>
        <div>H: <strong>${data.high.toFixed(2)}</strong></div>
        <div>L: <strong>${data.low.toFixed(2)}</strong></div>
        <div>C: <strong>${data.close.toFixed(2)}</strong></div>
        <div>${dateStr}</div>
    `;
}

function loadTimeframeData(tf) {
    const tfData = chartData[tf] || [];
    if (!tfData.length) { alert('Brak danych dla tego timeframe'); return; }
    candleSeries.setData(prepareCandleData(tfData));
    updateLegend(tfData[tfData.length-1]);
    document.querySelectorAll('.timeframe-btn').forEach(btn=>btn.classList.remove('active'));
    document.querySelector(`.timeframe-btn[data-tf="${tf}"]`)?.classList.add('active');
}

document.querySelectorAll('.timeframe-btn').forEach(btn=>{
    btn.addEventListener('click',()=>{currentTimeframe=btn.dataset.tf; loadTimeframeData(currentTimeframe)});
});

function resizeChart() {
    chart.applyOptions({width:chartContainer.clientWidth,height:chartContainer.clientHeight});
}
window.addEventListener('resize', resizeChart);
window.addEventListener('load', ()=>{
    resizeChart();
    loadTimeframeData(currentTimeframe);
});
chart.subscribeCrosshairMove(param => {
    if (!param.seriesPrices) return;
    const data = param.seriesPrices.get(candleSeries);
    if (data) updateLegend(data);
});


let isDrawingMode = false;
let isFibMode = false;
let drawingPoints = [];
let currentLine = null;
let savedLines = [];
let fibLines = [];
let isShiftKeyPressed = false;

const lineToolBtn = document.getElementById('line-tool');
const fibToolBtn = document.getElementById('fib-tool');
const clearDrawingsBtn = document.getElementById('clear-drawings');

lineToolBtn.addEventListener('click', () => {
    isDrawingMode = !isDrawingMode;
    lineToolBtn.classList.toggle('active', isDrawingMode);
    
    isFibMode = false;
    fibToolBtn.classList.remove('active');
    
    chartContainer.style.cursor = isDrawingMode ? 'crosshair' : 'default';
    
    if (!isDrawingMode && drawingPoints.length === 1) {
        drawingPoints = [];
        if (currentLine) {
            chart.removeSeries(currentLine);
            currentLine = null;
        }
    }
});

fibToolBtn.addEventListener('click', () => {
    isFibMode = !isFibMode;
    fibToolBtn.classList.toggle('active', isFibMode);
    
    isDrawingMode = false;
    lineToolBtn.classList.remove('active');
    
    chartContainer.style.cursor = isFibMode ? 'crosshair' : 'default';
    
    if (currentLine) {
        chart.removeSeries(currentLine);
        currentLine = null;
    }
    drawingPoints = [];
});


document.addEventListener('keydown', (e)=>{
    if (e.key === 'Shift'){
        isShiftKeyPressed = true;
    }
})

document.addEventListener('keyup', (e)=>{
    if (e.key === 'Shift'){
        isShiftKeyPressed = false;
    }
})

clearDrawingsBtn.addEventListener('click', () => {
    savedLines.forEach(l => chart.removeSeries(l));
    savedLines = [];
    
    fibLines.forEach(l => chart.removeSeries(l));
    fibLines = [];
    
    if (currentLine) {
        chart.removeSeries(currentLine);
        currentLine = null;
        drawingPoints = [];
    }
});
chartContainer.addEventListener('mousedown', e => {
    if (!isDrawingMode && !isFibMode) return;

    const rect = chartContainer.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const time = chart.timeScale().coordinateToTime(x);
    const price = candleSeries.coordinateToPrice(y);

    if (time == null || price == null) {
        console.warn("Clicked outside valid chart area, ignoring.");
        return;
    }

    try {
        if (isDrawingMode) {
            // Logika rysowania zwykłej linii
            if (drawingPoints.length === 0) {
                drawingPoints.push({ time, price });
                currentLine = chart.addSeries(LightweightCharts.LineSeries, {
                    color: '#ff5722',
                    lineWidth: 2,
                    lastValueVisible: false,
                    priceLineVisible: false
                });

                currentLine.setData([
                    { time: drawingPoints[0].time, value: drawingPoints[0].price },
                    { time: drawingPoints[0].time, value: drawingPoints[0].price }
                ]);
            } else if (drawingPoints.length === 1) {
                drawingPoints.push({ time, price });
                if (currentLine) {
                    chart.removeSeries(currentLine);
                }
                const newLine = chart.addSeries(LightweightCharts.LineSeries, {
                    color: '#ff5722',
                    lineWidth: 2,
                    lastValueVisible: false,
                    priceLineVisible: false
                });
                
                // Sort points by time for the library (technical requirement)
                const pointsForLibrary = [
                    { time: drawingPoints[0].time, value: drawingPoints[0].price },
                    { time: drawingPoints[1].time, value: drawingPoints[1].price }
                ].sort((a, b) => a.time - b.time);
                
                newLine.setData(pointsForLibrary);
                savedLines.push(newLine);
                currentLine = null;
                drawingPoints = [];
            }
        } else if (isFibMode) {
            // Logika rysowania Fibonacci retracement
            if (drawingPoints.length === 0) {
                // Pierwszy punkt Fibonacciego
                drawingPoints.push({ time, price });
                currentLine = chart.addSeries(LightweightCharts.LineSeries, {
                    color: '#2962FF',
                    lineWidth: 2,
                    lastValueVisible: false,
                    priceLineVisible: false
                });

                currentLine.setData([
                    { time: drawingPoints[0].time, value: drawingPoints[0].price },
                    { time: drawingPoints[0].time, value: drawingPoints[0].price }
                ]);
            } else if (drawingPoints.length === 1) {
                // Drugi punkt Fibonacciego - rysujemy poziomy
                drawingPoints.push({ time, price });
                
                // Usuwamy linię pomocniczą
                if (currentLine) {
                    chart.removeSeries(currentLine);
                    currentLine = null;
                }
                
                const startPrice = drawingPoints[0].price;
                const endPrice = drawingPoints[1].price;
                const priceDiff = endPrice - startPrice;
                
                // Zdefiniowane poziomy Fibonacci
                const fibLevels = [-0.5, 0, 0.5, 0.62, 0.705, 0.79, 1];
                
                // Rysujemy linie dla każdego poziomu
                for (const level of fibLevels) {
                    const fibPrice = startPrice + priceDiff * (1- level);
                    
                    // Tworzymy linię poziomą na poziomie Fib
                    const fibLine = chart.addSeries(LightweightCharts.LineSeries, {
                        color: level === 0 || level === 1 ? '#FF6D00' : '#2962FF',
                        lineWidth: level === 0 || level === 1 ? 2 : 1,
                        lastValueVisible: true,
                        lastValueAlign: 'right',
                        title: `Fib ${level}`,
                        priceLineVisible: false
                    });
                    
                    const visibleRange = chart.timeScale().getVisibleRange();
                    let startTime, endTime;
                    
                    if (visibleRange) {
                        startTime = visibleRange.from;
                        endTime = visibleRange.to;
                    } else {
                        const sortedTimes = [drawingPoints[0].time, drawingPoints[1].time].sort((a, b) => a - b);
                        startTime = sortedTimes[0];
                        endTime = sortedTimes[1];
                    }
                    
                    // Rysujemy linię na całym widocznym zakresie
                    const sortedPoints = [
                        { time: startTime, value: fibPrice },
                        { time: endTime, value: fibPrice }
                    ].sort((a, b) => a.time - b.time);
                    
                    fibLine.setData(sortedPoints);
                    
                    // Dodajemy etykietę z poziomem i ceną
                    fibLine.applyOptions({
                        lastValueText: `${level} (${fibPrice.toFixed(2)})`
                    });
                    
                    fibLines.push(fibLine);
                }
                drawingPoints = [];
                
                // Rysujemy główną linię trendu
                const trendLine = chart.addSeries(LightweightCharts.LineSeries, {
                    color: '#FF6D00',
                    lineWidth: 2,
                    lastValueVisible: false,
                    priceLineVisible: false
                });
                
                const sortedPoints = [
                    { time: drawingPoints[0].time, value: drawingPoints[0].price },
                    { time: drawingPoints[1].time, value: drawingPoints[1].price }
                ].sort((a, b) => a.time - b.time);
                
                trendLine.setData(sortedPoints);
                fibLines.push(trendLine);
                
                drawingPoints = [];
            }
        }
    } catch (err) {
        console.error("Error during drawing:", err);
        if (currentLine) {
            chart.removeSeries(currentLine);
            currentLine = null;
        }
        drawingPoints = [];
    }
});

chartContainer.addEventListener('mousemove', e => {
    if ((!isDrawingMode && !isFibMode) || drawingPoints.length !== 1 || !currentLine) return;

    const rect = chartContainer.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const time = chart.timeScale().coordinateToTime(x);
    const price = candleSeries.coordinateToPrice(y);

    if (time == null || price == null) return;

    try {
        let finalTime = time;
        let finalPrice = price;
        
        if (isShiftKeyPressed && isDrawingMode) {  // Stosujemy ograniczenie kąta tylko dla zwykłych linii
            const startX = chart.timeScale().timeToCoordinate(drawingPoints[0].time);
            const startY = candleSeries.priceToCoordinate(drawingPoints[0].price);
            
            if (startX !== null && startY !== null) {
                const deltaX = x - startX;
                const deltaY = y - startY;
                
                let angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
                angle = Math.round(angle / 45) * 45;
                
                const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                const newEndX = startX + length * Math.cos(angle * Math.PI / 180);
                const newEndY = startY + length * Math.sin(angle * Math.PI / 180);
                
                const newTime = chart.timeScale().coordinateToTime(newEndX);
                const newPrice = candleSeries.coordinateToPrice(newEndY);
                
                if (newTime !== null && newPrice !== null) {
                    finalTime = newTime;
                    finalPrice = newPrice;
                }
            }
        }
        
        const sortedPoints = [
            { time: drawingPoints[0].time, value: drawingPoints[0].price },
            { time: finalTime, value: finalPrice }
        ].sort((a, b) => a.time - b.time);
        
        currentLine.setData(sortedPoints);
    } catch (err) {
        console.error("Error updating line:", err);
    }
});

</script>
{% endblock %}
