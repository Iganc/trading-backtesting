{% extends 'backtest_app/base.html' %}
{% load static %}
{% load humanize %}

{% block title %}{{ display_symbol }} Chart{% endblock %}

{% block extra_head %}
    <!-- Dodanie biblioteki Lightweight Charts -->
    <script src="https://unpkg.com/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        .chart-container {
            position: relative;
            height: 600px;
            width: 100%;
            margin-top: 20px;
        }
        .info {
            background: #f0f0f0; 
            padding: 15px; 
            margin: 10px 0; 
            border-radius: 5px;
        }
        .timeframe-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        .timeframe-btn {
            padding: 8px 16px;
            background: #e0e0e0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        .timeframe-btn.active {
            background: #007bff;
            color: white;
        }
        .warning {
            background-color: #fff3cd;
            color: #856404;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .legend {
            position: absolute;
            z-index: 10;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.85);
            padding: 8px;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            font-size: 14px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
    </style>
{% endblock %}

{% block content %}
    <a href="/" class="home-link">Powrót do strony głównej</a>
    <h1>{{ display_symbol }} Chart</h1>
    
    <div class="info">
        <p><strong>Symbol:</strong> {{ display_symbol }}</p>
        <p><strong>Records:</strong> {{ count|intcomma }}</p>
        <p><strong>Date Range:</strong> {{ start_date }} to {{ end_date }}</p>
    </div>
    
    {% if data_warning %}
    <div class="warning">
        <strong>Uwaga:</strong> {{ data_warning }}
    </div>
    {% endif %}
    
    <div class="timeframe-buttons">
        <button class="timeframe-btn" data-tf="1m">1m</button>
        <button class="timeframe-btn" data-tf="5m">5m</button>
        <button class="timeframe-btn" data-tf="15m">15m</button>
        <button class="timeframe-btn active" data-tf="1h">1h</button>
        <button class="timeframe-btn" data-tf="4h">4h</button>
        <button class="timeframe-btn" data-tf="1d">1d</button>
    </div>
    
    <div id="chart-container" class="chart-container">
        <div id="legend" class="legend"></div>
    </div>

        <!-- Dodaj tuż przed zamknięciem bloku content -->
    {% if debug %}
    <div style="margin-top: 30px; padding: 15px; background-color: #f5f5f5; border: 1px solid #ddd;">
        <h3>Debug Info:</h3>
        <p>Display Symbol: {{ display_symbol }}</p>
        <p>Count: {{ count }}</p>
        <p>Chart Data Length (JSON): {{ chart_data|length }} bytes</p>
        <pre style="max-height: 200px; overflow: auto; background: #eee; padding: 10px;">{{ chart_data|slice:":500" }}...</pre>
    </div>
    {% endif %}
{% endblock %}

{% block scripts %}
<script>
    
    // Dane z serwera
    console.log("Template loaded");
    
    // Dane z serwera
    let chartData;
    try {
        console.log("Raw chart_data length:", '{{ chart_data|escapejs }}'.length);
        chartData = JSON.parse('{{ chart_data|escapejs }}');
        console.log("Chart data parsed successfully:", Object.keys(chartData));
        console.log("Timeframes available:", Object.keys(chartData));
        console.log("Sample data points in 1h:", chartData['1h'] ? chartData['1h'].length : 'N/A');
    } catch (error) {
        console.error("Błąd parsowania danych JSON:", error);
        console.error("Raw data preview:", '{{ chart_data|escapejs }}'.substring(0, 100) + '...');
        chartData = {};
    }

    console.log("LightweightCharts loaded:", typeof LightweightCharts !== 'undefined');
    
    // Elementy DOM
    const chartContainer = document.getElementById('chart-container');
    const legendElement = document.getElementById('legend');
    
    // Konfiguracja wykresu
    const chartOptions = {
        layout: {
            background: { color: '#ffffff' },
            textColor: '#333',
        },
        grid: {
            vertLines: { color: '#f0f0f0' },
            horzLines: { color: '#f0f0f0' },
        },
        crosshair: {
            mode: LightweightCharts.CrosshairMode.Normal,
        },
        rightPriceScale: {
            borderColor: '#d1d4dc',
        },
        timeScale: {
            borderColor: '#d1d4dc',
            timeVisible: true,
            secondsVisible: false,
        },
        handleScroll: {
            vertTouchDrag: false,
        },
    };
    
    // Tworzenie wykresu
    const chart = LightweightCharts.createChart(chartContainer, chartOptions);
    
    // Dynamiczna zmiana rozmiaru wykresu
    function resizeChart() {
        chart.applyOptions({
            width: chartContainer.clientWidth,
            height: chartContainer.clientHeight
        });
    }
    
    // Nasłuchiwanie na zmiany rozmiaru okna
    window.addEventListener('resize', resizeChart);
    resizeChart();
    
    // Przygotowanie danych do wykresu świecowego
    function prepareCandleData(data) {
        return data.map(item => ({
            time: item.time,
            open: item.open,
            high: item.high,
            low: item.low,
            close: item.close,
        }));
    }
    
    // Dodawanie serii danych do wykresu
    const candleSeries = chart.addCandlestickSeries({
        upColor: '#26a69a',
        downColor: '#ef5350',
        borderVisible: false,
        wickUpColor: '#26a69a',
        wickDownColor: '#ef5350'
    });
    
    // Wybór domyślnego timeframe'a
    let currentTimeframe = '1h';
    loadTimeframeData(currentTimeframe);
    
    // Funkcja do ładowania danych dla wybranego timeframe'a
    function loadTimeframeData(timeframe) {
        const tfData = chartData[timeframe] || [];
        
        if (tfData.length === 0) {
            alert('Brak danych dla wybranego timeframe\'a');
            return;
        }
        
        candleSeries.setData(prepareCandleData(tfData));
        
        // Uaktualnienie legendy
        updateLegend(tfData[tfData.length - 1]);
        
        // Zaznaczenie aktywnego przycisku
        document.querySelectorAll('.timeframe-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.querySelector(`.timeframe-btn[data-tf="${timeframe}"]`).classList.add('active');
        
        // Przewinięcie do odpowiedniego zakresu dat
        const visibleRange = Math.min(100, tfData.length);
        chart.timeScale().setVisibleRange({
            from: tfData[Math.max(0, tfData.length - visibleRange)].time,
            to: tfData[tfData.length - 1].time
        });
    }
    
    // Dodanie nasłuchiwania na przyciski timeframe
    document.querySelectorAll('.timeframe-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const timeframe = this.getAttribute('data-tf');
            currentTimeframe = timeframe;
            loadTimeframeData(timeframe);
        });
    });
    
    // Uaktualnienie legendy przy poruszaniu kursorem
    chart.subscribeCrosshairMove(param => {
        if (
            param.point === undefined || 
            !param.time || 
            param.point.x < 0 || 
            param.point.x > chartContainer.clientWidth || 
            param.point.y < 0 || 
            param.point.y > chartContainer.clientHeight
        ) {
            // Poza wykresem - pokaż ostatnią wartość
            const lastData = chartData[currentTimeframe][chartData[currentTimeframe].length - 1];
            updateLegend(lastData);
        } else {
            // Na wykresie - pokaż wartość pod kursorem
            const data = param.seriesPrices.get(candleSeries);
            if (data) {
                updateLegend(data);
            }
        }
    });
    
    // Aktualizacja legendy
    function updateLegend(data) {
        if (!data) return;
        
        // Formatowanie daty
        let dateStr = '';
        if (data.time) {
            const date = new Date(data.time * 1000);
            dateStr = date.toLocaleString();
        }
        
        legendElement.innerHTML = `
            <div>O: <strong>${data.open.toFixed(2)}</strong></div>
            <div>H: <strong>${data.high.toFixed(2)}</strong></div>
            <div>L: <strong>${data.low.toFixed(2)}</strong></div>
            <div>C: <strong>${data.close.toFixed(2)}</strong></div>
            <div>${dateStr}</div>
        `;
    }
</script>
{% endblock %}